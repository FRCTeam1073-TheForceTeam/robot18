package org.usfirst.frc1073.robot18.commands;

import org.usfirst.frc1073.robot18.Robot;
import org.usfirst.frc1073.robot18.RobotMap;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class AdvancedDrive2 extends Command {
	
	 private double m_inches;
	 
	    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	 	double dest,originalLeft,originalRight,originalHeading,currentLeft,currentRight;
	 	double encoderDif,gyroDif,currentAvg,currentSpeed,currentDist,offSet,gyroOffSet;
	 	double encoderOffSet,currentLeftSpeed,currentRightSpeed, originalDist;
	    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	    public AdvancedDrive2(double inches) {

	    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING


	        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
	    	
	        m_inches = inches;
	    	dest = m_inches * 1440 * 3.9 * Math.PI;
	    	
	    	//Zone around destination to stop
	    	offSet = 1.5;
	    	
	    	//Coefficient to multiply gyroDif
	    	gyroOffSet = .01;
	    	
	    	//Coefficient to  multiply encoderDif
	    	encoderOffSet = .0001;
	        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	        requires(Robot.drivetrain);

	    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	    }

	    // Called just before this Command runs the first time
	    protected void initialize() {
	    	RobotMap.leftMotor1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 10);
	    	RobotMap.leftMotor1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 10);
	    	originalLeft = RobotMap.leftMotor1.getSelectedSensorPosition(0);
	    	originalRight = RobotMap.rightMotor1.getSelectedSensorPosition(0);
	    	originalHeading = RobotMap.headingGyro.getAngle();
	    	originalDist = ((originalLeft + originalRight) / 2) * 3.9 * Math.PI * 1440;
	    }

	    // Called repeatedly when this Command is scheduled to run
	    protected void execute() {
	    	//Set all of my variables that need to updated every loop
	    	currentLeft = RobotMap.leftMotor1.getSelectedSensorPosition(0)*-1;
	    	currentRight = RobotMap.rightMotor1.getSelectedSensorPosition(0);
	    	encoderDif = currentLeft - currentRight;
	    	gyroDif = Math.abs(originalHeading - RobotMap.headingGyro.getAngle());
	    	currentAvg = (currentLeft + currentRight) / 2;
	    	currentDist = currentAvg*1440*3.9*Math.PI;
	    	currentSpeed = (-(4 / Math.pow(dest, 2)) * Math.pow(currentDist - originalDist, 2) - ((4 / dest) * (currentDist - originalDist)));
	    	
	    	//Set floor to currentSpeed
	    	if(currentSpeed > 0 && currentSpeed < .2) currentSpeed = .2;
	    	if(currentSpeed < 0 && currentSpeed > -.2) currentSpeed = -.2;
	    	
	    	//Start correcting turn
	    	currentLeftSpeed = currentSpeed;
	    	currentRightSpeed = currentSpeed;
	    	
	    	//Correct for encoder differences
	    	currentLeftSpeed -= (encoderDif * encoderOffSet);
	    	currentRightSpeed += (encoderDif * encoderOffSet);
	    	
	    	//Correct for gyro differences
	    	currentLeftSpeed -= (gyroDif * gyroOffSet);
	    	currentRightSpeed += (gyroDif * gyroOffSet);
	    	
//	    	//Invert left side
//	    	currentLeftSpeed *= -1;
	    	
	    	//Put data to smart dashboard
	    	SmartDashboard.putNumber("left MAX", currentLeft);
	    	SmartDashboard.putNumber("right MAX", currentRight);
	    	
	    	//Set the motors
	    	Robot.drivetrain.difDrive.arcadeDrive(currentSpeed, /*(encoderDif * encoderOffSet) + (gyroDif * gyroOffSet)*/ 0);
//	    	RobotMap.leftMotor3E.set(ControlMode.PercentOutput, currentSpeed);
//	    	RobotMap.rightMotor3E.set(ControlMode.PercentOutput, currentSpeed);
//	    	Robot.drivetrain.basicDrive(currentLeftSpeed, currentRightSpeed);
//	    	Robot.drivetrain.basicDrive(currentSpeed, currentSpeed);
	    }

	    // Make this return true when this Command no longer needs to run execute()
	    protected boolean isFinished() {
	    	boolean done = false;
	    	if(currentAvg >= (dest-offSet)) done = true;
	    	return done;
	    }

	    // Called once after isFinished returns true
	    protected void end() {
	    	Robot.drivetrain.basicDrive(0, 0);
	    }

	    // Called when another command which requires one or more of the same
	    // subsystems is scheduled to run
	    protected void interrupted() {
	    	Robot.drivetrain.basicDrive(0, 0);
	    }
}
